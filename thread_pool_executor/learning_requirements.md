# 学習要件定義書 - ThreadPoolExecutor

## 1. 学習目的
- ThreadPoolExecutorのインスタンス生成プロセスを理解する
- `<<` メソッドの実装と動作を詳細に把握する
- タスクがキューに追加されてからワーカースレッドで実行されるまでの流れを追跡する
- `<<` メソッド実行時の内部状態変化を理解する
- **排他制御が必要なタイミングとその理由を特定する**
- **どの共有リソースに対してどのような排他制御が行われているかを理解する**

## 2. 既知と未知

### 2.1 既知
- ThreadPoolExecutorはconcurrent-rubyのExecutor実装の一つ
- `<<` はタスクを実行キューに追加するメソッド
- スレッドプールが複数のワーカースレッドを管理している
- 複数スレッドが同じリソースにアクセスする際は排他制御が必要

### 2.2 未知・疑問点
- ThreadPoolExecutorインスタンス生成時に何が初期化されるのか
- `<<` メソッドの具体的な実装内容
- タスクがどのようにキューに格納されるのか
- ワーカースレッドはどのタイミングでタスクを取得するのか
- `<<` 実行時のエラーハンドリング
- スレッドプールが満杯の時の動作
- **どの操作で排他制御（mutex、lock等）が使われているか**
- **タスクキューへのアクセス時の排他制御**
- **ワーカースレッド管理時の排他制御**
- **状態変更（running/shutdown等）時の排他制御**
- **なぜそのタイミングで排他制御が必要なのか（競合状態の回避）**

## 3. 仮説と検証方針

| 疑問/仮説 | どのコード/資料で確認する？ | 検証方法 | 完了基準 |
|-----------|------------------------------|----------|----------|
| インスタンス生成時にワーカースレッドが起動される | `initialize` メソッド | コード読解とデバッグ出力 | 初期化フローを図解できる |
| `<<` メソッドはタスクをキューに追加する | `<<` メソッドの実装 | ソースコード追跡 | メソッドの処理ステップを説明できる |
| キューからワーカースレッドがタスクを取得する | ワーカースレッドのメインループ | 実装確認と実際の動作テスト | データフローを図示できる |
| `<<` は非同期で即座に制御を返す | メソッドの戻り値と実行時間 | 実際のコード実行とタイミング測定 | 非同期性を確認できる |
| **タスクキューへの追加時にlockが必要** | キュー操作周辺のコード | mutex/lock使用箇所の特定 | 排他制御箇所を列挙できる |
| **複数スレッドが同時にタスクを取得しようとする際に競合** | ワーカースレッドのタスク取得部分 | 同期プリミティブの確認 | 競合回避メカニズムを説明できる |
| **プール状態の変更時に排他制御が必要** | shutdown、状態管理メソッド | 状態変更時のロック確認 | どの状態変更で排他制御が必要か説明できる |
| プラットフォーム別で実装が異なる | Ruby/Java実装の比較 | 各実装ファイルの読解 | 実装差異を列挙できる |

## 4. 優先度と学習順序

1. **インスタンス生成の追跡** - `new` から `initialize` までの流れ
2. **`<<` メソッドの実装解析** - メソッドの詳細な動作
3. **排他制御ポイントの特定** - mutex/lock使用箇所の特定と理由
4. **タスクキューの仕組み** - タスクの格納と取得時の排他制御
5. **ワーカースレッドの動作** - タスク実行のライフサイクルと同期
6. **状態管理と排他制御** - プール状態変更時の排他制御
7. **エラーケースの確認** - 異常系での動作
8. **実際の動作確認** - デバッグ出力付きサンプルコード

## 5. 期待アウトプット・定着方法

- **フローチャート**: インスタンス生成から `<<` 実行完了までの処理フロー
- **シーケンス図**: オブジェクト間のメソッド呼び出しシーケンス
- **排他制御マップ**: どの操作でどの排他制御が使われているかの一覧
- **競合状態分析**: 排他制御がない場合に発生する問題の説明
- **デバッグコード**: 内部状態を可視化するサンプルプログラム
- **実装ノート**: 重要なメソッドとその役割の整理
- **動作確認レポート**: 実際の実行結果と期待動作の比較

## 6. リスク/詰まりポイントと回避策

- **継承階層が複雑で `<<` の実装場所が分からない**: クラス継承関係を最初に整理し、メソッド探索を体系的に行う
- **排他制御の実装が複雑すぎて理解困難**: まず「どこで」使われているかを特定し、「なぜ」必要かは後から理解
- **内部のスレッド同期が複雑**: 同期処理の詳細は後回しにし、まず高レベルなデータフローを理解
- **プラットフォーム固有の実装で混乱**: 最初はRuby実装のみに集中し、理解後に他実装を確認
- **非同期処理のデバッグが困難**: ログ出力とスレッドIDを使った追跡方法を確立
- **競合状態の再現が困難**: 意図的に競合を発生させるテストコードを作成
- **実際の動作とコードの乖離**: 小さなテストケースから始めて段階的に複雑化